The Flask Mega-Tutorial Part IX: Pagination
===

原文地址: [The Flask Mega-Tutorial Part XIV: Ajax](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xiv-ajax)

这是 Flask Mega-Tutorial 第十四部分，在本章我将会演示如何添加一个实时的语言翻译功能，使用了微软的翻译服务和一些 JavaScript。

在本章，我将离开服务端的开发，致力于和服务端同等重要的客户端组件功能。你看到过一些站点在用户生成内容旁边的翻译链接了吗？这些链接都会触发一个实时的内容翻译。翻译好的内容会显示在原有内容的下面。谷歌会在外文搜索页面显示它，Facebook 的博文，Twitter 的 tweets 都会显示。下来我会向你展示如何添加一个非常类似的功能到我们的微博上。

本章的 Github 链接为：[Browse](https://github.com/miguelgrinberg/microblog/tree/v0.14), [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.14.zip), [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.13...v0.14)

服务端 VS 客户端
===

在我已经遵循了很久的传统服务端模型中，有一个客户端(用户使用的 web 浏览器)会发起 HTTP 请求到应用服务器上。一个请求可以简单的请求 HTML 页面，比如你点击的 Profile 链接，或者触发一个动作，比如在你编辑个人信息之后的提交按钮。两种请求类型，服务器都是通过发送给客户端一个新的 web 页面来完成请求的，不论是直接的还是重定向的。客户端则会使用新的页面来替换旧的页面。这种循环一直进行，只要用户还在该应用的站点上。在这种模型里，服务端完成了所有工作，而客户端只是显示 web 页面并且允许用户输入。

还有一种不同的模型，这种模型里客户端会扮演更加活跃的角色，客户端会发起请求，服务端会响应一个 web 页面，但是不同于之前的例子，并不是所有的页面数据都是 HTML，页面的有些部分是代码，一般是以 JavaScript 写的。一旦客户端接收到页面之后就会显示出 HTML 部分，并且执行代码。从现在开始你就有一个可用的客户端，它会很少甚至不和服务器交互。在一个严格的客户端应用里，首先下载整个应用，然后应用就在客户机上运行，只有在提取或者存储数据以及对 web 页面外观做动态更改的时候才会和服务端交互。这种应用被称作单页应用或者 SPAs。

大多数应用是这两种模型的混合体，使用了两者的技术。我的微博应用基本上是一个服务器端应用，但是现在我将要给它增加一些客户端动作。为了给用户微博做实时的翻译，客户浏览器将会给服务器发送异步请求，服务器的响应会导致客户端进行页面刷新。客户端就会将翻译动态的插入到当前页面。这种技术被称为 Ajax，是 Asynchronous JavaScript and XML 的缩写(目前 XML 基本上被 JSON 所代替)。

实时翻译工作流
===

幸亏有 Flask-Babel 使得应用对于外文有良好的支持，这样我可以将微博翻译成尽可能多的语言称为可能。当然，忽略了一点。用户一般是用他们自己的语言书写微博，因此很有可能用户会遇到一篇完全不知道什么语言写的微博。自动翻译的质量现在仍然不够好，但是在大多数你只想知道文本的大概意思的情况下已经很不错了。

这是一个使用 Ajax 服务实现的理想功能。考虑到首页或者探索页会显示多个微博，一些可能是以外文书写的。如果我使用传统的服务器端技术实现翻译，那么可能会导致原始页面会被新的页面替代。事实上在诸多微博中翻译一篇并不是一个足够大的动作需要整个页面进行更新，如果能够在原始文本下动态插入翻译的文章而不影响页面其他部分会是最好的。

实现实时自动翻译需要这几步。第一，我需要确定文本使用什么语言去翻译。而且我需要知道每个用户常用语言，因为我想在用户没有使用的语言旁边显示翻译链接。当用户点击翻译链接的时候，我需要给服务器发送 Ajax 请求，之后服务器会调用第三方的翻译 API。一旦服务器返回翻译后的文章，客户端 JavaScript 代码会动态的将文本插入到页面。你应该可以发现，这有一些比较重要的问题，下来我们会一个个解释。

语言辨别
===

